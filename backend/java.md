# 基础概念

## Java语言特性

### Java vs C++

- Java只支持单继承，但可以实现多个接口，弥补单继承的短板，而C++支持多继承
  - 多继承本身存在菱形问题，B和C继承了A，D继承了B和C，如果B和C重写了A的方法，在D中调用时会存在歧义
  - 多继承会让类之间的关系变得复杂，难以维护
  - JDK9引入了默认方法，如果A实现了接口B，C实现了B且继承了A，那调用方法时调用A重写的方法
- Java的内存管理是由垃圾回收线程在后台自动处理的，C++的内存管理需要开发者手动维护
- Java具有平台无关性，字节码可以跨平台使用
- Java只支持方法重载，不支持运算符重载，C++两者都支持
- Java不提供指针，内存访问安全性更高

------

### 扩展：多接口实现不存在菱形问题

多实现不会存在菱形问题，因为一个接口中的方法，因为在实现类中，这个方法是一定要被重写的，也就是说调用的方法一定是自己重写的方法，不会存在歧义

JDK9引入了接口默认方法，默认方法存在菱形问题，默认方法特例：如果A实现了接口B，C继承了A，同时实现了B，那调用方法时，调用的是重写过的方法；如果一个类实现了A和B两个接口，两个接口有相同的默认方法，那类必须重写这个方法，否则存在歧义

如果A、B两个接口有同名方法，参数也相同，只有返回值不同，这样一个类是不能同时实现A和B的，因为方法签名只由方法名和参数决定，返回值并不属于签名的一部分，这种情况下编译器会报错

------

### Java三大特性

- 平台无关性（字节码和不同系统的JVM实现是平台无关性的关键）
- 内存自动管理机制
- 面向对象（封装、继承、多态）

### Java的两大问题

- 冷启动问题：加载JVM -> JVM加载大量字节码文件 -> 代码执行，代码执行之前要进行大量的准备工作
- 运行时内存占用高：相比于提前编译，运行时编译的代码要多很多，造成无效的内存占用

解决以上问题的办法是采用提前编译AOT （静态编译）：程序运行之前进行编译，启动即巅峰，降低运行时内存占用

AOT是静态编译，不支持Java大量的动态运行时机制，比如反射，本质问题也就是将静态编译框架无法识别和处理的内容转化为其可识别的内容

### Java优势和劣势

- 优势
  - 强大的生态
  - 自动内存管理
  - 平台无关性（字节码文件本身不能跨平台，字节码和系统对应的JVM结合才能跨平台），JVM由C/C++开发

- 劣势
  - 半编译半解释型语言，性能和纯编译语言相比有差距
  - 冷启动问题
  - 内存占用高（垃圾线程回收，以及运行时代码分析等导致运行时内存占用比较高）

### 面向对象三大特性（Java为面向对象语言）

- 封装：对象的属性和方法隐藏在对象内部，仅能通过外部接口访问，增强安全性
- 继承：子类共享父类的属性和方法，提高代码复用性
- 多态：不同类的对象对同一方法作出不同响应，分为运行时多态（重写）和编译时多态（重载）
  - 切记：静态方法不能被重写，但是能够被覆盖，因为其在类加载时就和类绑定的，而重写是一个运行时行为

## 字节码

### JDK vs JRE vs JVM

- JDK包含了java开发的一些工具包，比如javadoc、javac、jconsole等等，辅助java开发的工具
- JRE是java程序的一组运行环境，包含JVM和一些基础的类库（提供常用的功能，比如IO等）
- JVM负责字节码的解释运行，是程序运行的底座

### JVM的作用

JVM是运行Java字节码的虚拟机，负责将编译器的编译结果也就是字节码加载进内存并转化成运行时数据结构，并对字节码逐行解释运行，字节码+不同系统的JVM的特定实现是实现Java语言平台无关性的关键所在

### Java为什么是半编译半解释

- 编译
  - java源代码需要通过javac编译成字节码
  - JIT会分析程序运行时状态，运行频率高的热点代码会被编译保存到codeCache中

- 解释：JVM对字节码是解释运行

### 字节码的作用

**为什么JVM不直接解释java源代码，而要先编译成字节码**

- 提高解释效率，java语言是一种高级语言，解释效率很差，字节码更接近机器语言，解释效率更高
- 提高安全性，编译器在将源代码翻译成字节码时，会进行一系列的权限验证和安全性检查，避免非法访问等问题，提高安全性
- 支持动态特性，java一些动态特性依赖于字节码（动态代理运行时生成字节码）

### 采用字节码的好处

- 字节码相对于Java源代码更接近计算机底层，执行效率更高
- 字节码面向虚拟机，而不面向操作系统，字节码+JVM可以实现一次编译，处处运行

字节码解决了解释型语言执行效率低的问题，也保留了解释型语言可移植的优点

### 编译模式（动态编译vs静态编译）

- AOT （静态编译）: 一次性将字节码编译成机器码，启动时间以及内存占用都很小，但是峰值性能相对较弱，而且不支持Java的动态特性，比如反射，安全性也更好
- JIT （动态编译）：逐行解释字节码，在运行时会收集运行信息，针对热点代码进行编译，由于会收集运行状态信息，极限处理能力更强，但是冷启动问题以及内存占用问题比较严重

**安全性对比**

- AOT是程序部署前完成编译，能够避免很多运行时攻击；在编译时对编译代码进行了加密，不容易被篡改和反编译
- JIT在程序运行时编译代码，存在运行时被攻击的风险，而且编译后的代码存储在缓存中，存在被篡改的可能

如何确定是否为热点代码：JIT会统计方法或者代码块在一定时间内的调用次数，如果超过了给定的阈值，就认为是热点代码对其编译，编译的代码存入codeCache，位于方法区

java代码执行时间越长，执行速度越快（JIT动态编译）

#### 静态编译识别动态特性

- 如果是Spring框架，可以采用社区开发的AOT Engine帮助解决
- 如果是非Spring框架，可以采用native-image-agent 的 Tracing Agent 来帮助解决动态内容无法被识别的问题

### JVM编译器

- Client编译器：注重启动速度和局部优化
  - C1编译器：启动速度快，但是性能要差一些，进行一些简单可靠的优化，比如常量传播和常量折叠（常量传播是指使用常量替换原有的变量，常量折叠是直接计算表达式结果）

- Server编译器：注重全局优化，会进行一些不可靠的激进优化，冷启动问题严重，适合长时间运行的后台程序，性能相比于Client编译器要更好
  - C2编译器：相比于C1编译器，会进行更深层次的优化，编译之后的代码质量更高，相对地，其编译耗时更久，但是代码的执行速度更快
  - Graal编译器：Graal相比于C2更加激进，倾向于基于预测进行激进优化，峰值性能更好，支持逃逸分析（一种确定指针作用范围的机制）

- 分层编译：结合C1和C2，追求启动速度和峰值性能的平衡，将JVM的执行状态分为5个层次
  - 常规的解释执行，无需提前编译，启动速度快，但执行效率低
  - 无运行状态收集的C1编译：会对代码进行简单的编译优化，编译速度快，优化程度低
  - 执行仅带有方法调用次数以及循环回边次数统计的C1编译
  - 收集运行状态的C1编译：不仅会对代码进行简单的编译优化，也会收集运行中详细的运行信息，为后续的深度优化提供依据
  - C2编译：根据收集的运行状态信息，对代码进行深度优化，编译时间长，但编译后的代码执行速度快

**以上两种编译器均属于JIT即时编译器**

### 优化：系统重启速度慢

重启负载很高，CPU使用率很高，然后一段时间后负载下降

- 问题原因：JIT编译器只有在方法调用次数达到阈值后才会将其编译存入codeCache，系统刚启动大部分代码是解释执行，所以负载很高，随着代码执行，热点代码被编译，系统负载下降
- 解决方案：启用分层编译，根据程序的运行状态动态调整编译策略（-XX:+TieredCompilation）

## 基本语法

### 运算符

- a+=b与a=a+b的区别：前者存在隐式类型转换，后者如果不是int类型，需要强制转换
- 移位运算符：**仅仅只有int和long支持移位**，short、byte和char类型都会先转化为int再移位

### 基本类型与包装类型

java每种基本类型占用的存储空间不会随着机器硬件架构的变化而变化

#### 区别

- 存储方式
- 内存占用
- 设计用途
- 默认值
- 比较方式

#### 包装类型缓存机制

Byte、Short、Integer、Long和Character都支持缓存机制，其中Integer的**缓存上限**可以修改

**Float与Double不支持缓存机制**

- 相较于整型，浮点型没有比较明确的热点区间
- 存在语义歧义，由于计算机位宽的限制，会对尾数截断，精度丢失

#### 浮点数精度丢失问题

计算机底层位宽有限，无法存储尾数过长的小数，会进行尾数截断，导致精度丢失

BigDecimal可以实现浮点数的运算，并且不存在精度丢失

注意：BigDecimal也是存在精度丢失的风险的，是因为double本身的限制，初始化BigDecimal必须使用String类型初始化

数值部分通过BigInteger表示，scale表示小数点位置，由于通过数组存储元素，性能相比于直接存储要差

#### 为什么保留int类型

- 基本数据类型直接存储在栈中，而包装类型需要先获取地址，再去堆中获取对象实例本身，int读写性能好
- int占用的内存空间更小，包装类型还要存储对象头等数据，还必须通过垃圾回收机制回收，int仅通过栈帧出入栈就可以自动回收，int存取性能更好

**扩展：Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化**，比如C/C++,在16位系统中，int为两字节

